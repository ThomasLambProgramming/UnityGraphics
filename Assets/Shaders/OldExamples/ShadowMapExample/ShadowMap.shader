Shader "Unlit/ShadowMap"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags
        {
            "RenderType"="Opaque"
        }
        LOD 100

        //Shadow caster pass.
        pass
        {
            Name "Shadow Caster"
            Tags
            {
                "LightMode"="ShadowCaster"
                "RenderType"="Opaque"
            }
            ZWrite on 
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            //Multi compile all the variants required for the shadow caster.
            #pragma multi_compile_shadowcaster
            //for the shadow caster functions / macros. 
            #include "UnityCG.cginc"
            //struct appdata
            //{
            //    //we only want the vert positions as input
            //    float4 vertPosition : POSITION;
            //};
            struct v2f
            {
                //only the vert positions are needed as output
                //float4 vertex : SV_POSITION;

                //Same as below for the appdata full struct in unity cg.
                V2F_SHADOW_CASTER;
            };
            //appdata_full is this but in the UnityCG.cginc
            /*
                struct appdata_full {
                    float4 vertex : POSITION;
                    float4 tangent : TANGENT;
                    float3 normal : NORMAL;
                    float4 texcoord : TEXCOORD0;
                    float4 texcoord1 : TEXCOORD1;
                    float4 texcoord2 : TEXCOORD2;
                    float4 texcoord3 : TEXCOORD3;
                    fixed4 color : COLOR;
                    UNITY_VERTEX_INPUT_INSTANCE_ID
                };
             */
            v2f vert (appdata_full v)
            {
                v2f o;
                //Takes the verts position coords to clip space and does normal offset calculation so we can have shadows in the normal maps which is pre cool.
                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);
                return o;
            }
            //because its just creating the shadow texture we do not need to return a color / process a color
            fixed4 frag(v2f i) : SV_Target
            {
                //Color output for shadow projection unity function.
                SHADOW_CASTER_FRAGMENT(i);
                //if we didnt have the above funciton we just return a black shadow.
                return 0;
            }
            ENDCG
        }
        //default color pass
        Pass
        {
            /*Continuing with the shader USB_shadow_map; in this section, you will define a texture to project
shadows onto your object. To do this you have to include LightMode in the color pass and make
it equal to ForwardBase, this way Unity will know that this pass will be affected by lighting.*/
            //my assumption from the above in the book is that the shadow texture is what affects the object itself and allows another object to cast a shadow on this object.
            
            
            //Also we are making a projection which works as a texture, not sure on how that works but putting it here to solidify that / if i ever read over this again.
            name "Shadow Map Texture"
            Tags
            {
                "RenderType"="Opaque"
                "LightMode"="ForwardBase"
            }
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
                //declare the uv coords for the shadow map
                float4 shadowCoord : TEXCOORD1;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            //dont declare a property for this as its generated by this code /lighting not getting a texture we already have.
            //as the shadowmap is a texture we need a sampler for it.
            sampler2D _ShadowMapTexture;

            float4 NFCToUV(float4 clipPos)
            {
                float4 o = clipPos * 0.5;

                #if defined(UNITY_HALF_TEXEL_OFFSET)
                //Direct3D and opengl differ on what they believe y to be (opengl = ^ direct3d = positive is down, projection params is a unity inbuilt to store -1 or 1 depending )
                o.xy = float2(o.x,o.y * _ProjectionParams.x) + o.w * _ScreenParams.zw;
                #else
                o.xy = float2(o.x,o.y * _ProjectionParams.x) + o.w;
                #endif
                
                o.zw = clipPos.zw;
                return o;
            }
            v2f vert(appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                o.shadowCoord = NFCToUV(o.vertex);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_MainTex, i.uv);
                
                float2 uvShadow = i.shadowCoord.xy / i.shadowCoord.w;
                float shadowColor = tex2D(_ShadowMapTexture, uvShadow).a;
                col.rgb *= shadowColor;
                return col;
            }
            ENDCG
        }

    }
}